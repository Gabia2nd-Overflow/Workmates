### Message 기능구현

- 여기서 짚고넘어가야 할것. 기존 USERDTO, 및 ChatRoomDTO 방식을 
- 중첩 클래스 방식, 정적 중첩 클래스 방식이라고 부릅니다. 
- Nested Class Pattern, Static Nesrted Class Pattern

- Gpt에 질문또는 코드를 생성할 때 정적 중첩 클래스 방식으로 DTO를 생성해 달라고 부탁하세요.

### JPA에서 자주 사용하는 대표적인 메서드 키워드를 정리해 드릴게요.

✅ 자주 쓰는 대표적 키워드
    키워드	-                   설명	-           반환타입 예시
- find	- 조건을 만족하는 데이터를 찾음	 -          객체 or 객체리스트
- exists	- 특정 조건의 데이터 존재 여부를 체크함	-   boolean
- count	- 특정 조건의 데이터 개수를 셈	-               long
- delete	- 특정 조건의 데이터를 삭제함	-       void or 삭제한 개수
- save	- 새로운 데이터 또는 수정한 데이터를 저장함	-   저장한 객체
- findAll	- 모든 데이터를 찾음 (또는 조건을 만족하는 모든 데이터를 찾음) - List

# 💬 Message 기능 개발 정리

이 문서는 Workmates 협업 메신저 프로젝트에서 구현한 `Message` 기능에 대한 구조 및 흐름을 설명합니다.

---

## ✅ 기능 개요

- **메시지 전송**: 사용자가 특정 채팅방에 메시지를 보냅니다.
- **메시지 조회**: 특정 채팅방의 모든 메시지를 시간순으로 불러옵니다.
- **단위 테스트**를 통해 기능의 안정성을 검증합니다.

---

## 📦 도메인 구성

### 📌 Message (엔터티)

- DB에 저장되는 메시지 객체입니다.
- 메시지를 보낸 사용자(`sender`), 채팅방(`chatroom`), 내용(`content`), 생성시간(`createdAt`)을 가집니다.
- `@PrePersist`를 이용해 저장 시 자동으로 생성시간이 기록됩니다.

---

## 📚 데이터 흐름

1. 프론트엔드가 메시지를 전송하면 → `MessageDTO.SendMessageRequest` 객체로 컨트롤러가 받음
2. 컨트롤러가 서비스에 메시지 전송 요청 → 서비스는 DB에서 사용자와 채팅방을 조회
3. 메시지 객체를 생성해 `MessageRepository`를 통해 저장
4. 저장된 메시지를 응답 DTO(`MessageDTO.MessageResponse`)로 변환 후 반환

---

## 🧩 DTO 설계 방식

- `MessageDTO` 클래스 안에 `SendMessageRequest`와 `MessageResponse`를 **정적 중첩 클래스(Static Nested Class)**로 구성
- 관련된 DTO들을 하나의 파일로 묶어서 구조적이고 직관적으로 관리
- `MessageResponse.from()` 메서드를 통해 엔티티 → DTO 변환 로직을 깔끔하게 정리

---

## 🔁 Repository

- `MessageRepository`는 `JpaRepository`를 상속받아 기본 CRUD 메서드 사용
- 채팅방 ID 기준으로 메시지를 시간순으로 조회하는 커스텀 메서드 정의:
  - `findAllByChatroomIdOrderByCreatedAtAsc(Long chatroomId)`

---

## 🛠 Service 기능

- `sendMessage(chatroomId, userId, content)`  
  → 채팅방과 사용자 유효성 검사 후 메시지 저장

- `getMessages(chatroomId)`  
  → 해당 채팅방의 메시지를 시간순으로 모두 조회

---

## 🧪 단위 테스트

- `메시지_전송_성공()` 테스트
  - 메시지를 저장하고 ID, 내용, 발신자, 채팅방이 정확히 연결되었는지 검증

- `채팅방의_메시지_조회_성공()` 테스트
  - 두 개의 메시지를 저장한 후, 조회 시 시간순으로 잘 불러오는지 확인

- 테스트는 `Builder` 패턴을 활용하여 객체를 간편하게 생성
- `@Transactional`로 DB 롤백을 자동화하여 독립성 보장

---

## ✅ 기타 기술 포인트

- DB 연동은 MySQL 사용
- 테스트 실행은 `.\gradlew test --tests "com.workmates.backend.service.MessageServiceTest"` 명령어 사용
- 메시지 저장 시 `createdAt`은 자동으로 `@PrePersist`에 의해 현재 시간 기록
- 엔티티 생성자를 직접 정의하지 않고 `@Builder`로 객체를 생성하여 유연성 확보

---

## 📌 정리

이 메시지 기능은 "사용자 → 채팅방 → 메시지 전송 및 조회" 흐름에 맞춰  
**JPA 기반으로 깔끔하게 구성**되었으며,  
**DTO 구조 리팩토링, 단위 테스트, 자동 시간 처리 등**을 통해 실용성과 유지보수성을 확보했습니다.



-------------------------------------------------------------------------------------

# ✅ Workmates 백엔드 선행 개발 리스트 (프론트 연동 없이 가능)

이 문서는 프론트엔드 없이 백엔드에서 먼저 개발 가능한 기능을 정리한 것입니다.  
기능 구현 순서를 기준으로 진행하며, 각 기능은 단독 테스트(Postman, 단위 테스트 등)로 확인 가능합니다.
## 앞으로 사용할 구조 
✅ 이 구조의 전문 용어
🔹 계층형 아키텍처 (Layered Architecture)

🔹 3계층 아키텍처 (Three-Tier Architecture)
📚 용어 설명
계층	설명	예시 (현재 구조 기준)
Presentation Layer (프레젠테이션 계층)	사용자의 요청을 받고 응답을 처리하는 계층	@RestController, Postman, React
Service Layer (서비스 계층)	비즈니스 로직을 처리하는 계층	ChatroomService, MessageService
Persistence Layer (영속성 계층)	DB와 데이터를 주고받는 계층	ChatroomRepository, MessageRepository, JPA
Database Layer (데이터베이스)	실제 데이터 저장소	MySQL, H2 등


---

## ✅ 개발 순서 및 작업 항목

### 🥇 1. WebSocket 메시지 전송/수신 기본 구조 구현

- Spring WebSocket 설정 (Stomp or SockJS 포함)
- 메시지 전송용 컨트롤러 (`@MessageMapping`)
- 특정 채팅방에 메시지 브로드캐스트 (`@SendTo`)
- 테스트용 클라이언트로 메시지 전송/수신 확인

---

### 🥈 2. 파일 첨부 기능 (API & 저장)

- Multipart 파일 업로드 API (`POST /api/messages/files`)
- 저장 위치: 로컬 디스크 또는 AWS S3 (후자 권장)
- 파일명 중복 방지 처리(UUID 등)
- 업로드된 파일을 메시지와 연동할 수 있는 구조 설계 (예: `Message` 엔티티에 `fileUrl` 컬럼)

---

### 🥉 3. 메시지 수정 및 삭제 기능

- 메시지 수정 API (`PATCH /api/messages/{id}`)
- 메시지 삭제 API (`DELETE /api/messages/{id}`)
- 작성자만 수정/삭제 가능하도록 검증
- 수정 시간 필드(`updatedAt`) 추가 및 `@PreUpdate` 처리

---

### 🟡 4. 채팅방 유형 분리 (채널 / DM)

- `Chatroom` 엔티티에 `type` 필드 추가 (Enum: `CHANNEL`, `DM`)
- `DM`의 경우 참여자 2명을 고정하고, 채널은 여러 명 가능하도록 구조 분리
- 채팅방 생성 시 유형 지정 기능 추가

---

### 🔵 5. 읽음 여부 처리

- `MessageRead` 엔티티 생성 (userId, messageId, readAt 등)
- 메시지 읽음 체크 시 등록
- 사용자가 마지막으로 읽은 메시지 ID 기준으로 안 읽은 개수 조회 가능하도록 API 설계

---

### 🟢 6. 안 읽은 메시지 수 API

- 채팅방별 안 읽은 메시지 수 반환 API (`GET /api/chatrooms/{id}/unread`)
- 읽음 처리와 연동하여 프론트 알림 배지용 데이터 제공
- 추후 사용자별로 구독 설정도 확장 가능

---

## 📌 추가 참고

- 위 기능들은 모두 Postman 또는 단위 테스트로 테스트 가능
- WebSocket은 프론트가 없어도 웹 테스트 툴(`websocket.org`, `Stomp client`, `WenSocket King`)으로 테스트 가능
- 확장성을 고려하여 서비스/엔티티 분리 설계 권장

---

## 📦 진행 순서 요약

| 우선순위 | 기능 | 상태 |
|----------|------|------|
| 🥇 | WebSocket 메시지 기본 구조 | ☐ |
| 🥈 | 파일 업로드 API | ☐ |
| 🥉 | 메시지 수정/삭제 API | ☐ |
| 🟡 | 채널/DM 유형 분리 | ☐ |
| 🔵 | 읽음 처리 구조 및 API | ☐ |
| 🟢 | 안 읽은 메시지 수 API | ☐ |

---

