## 로그인, 로그아웃 세션 프론트와 백엔드 연동

## 회원가입기능 백엔드와 연동.

## 2025 07 30 - 31

실시간 메세지 전송및, 데이터베이스에 메세지 내역 저장 구현.  
클라이언트를 껏다 켜도 DB에서 기존 메세지 가져옴 .

# 💬 ChatroomDetail 기능 전체 구조 정리

채팅방 상세 페이지에서 실시간 메시지를 주고받는 기능을 프론트엔드와 백엔드 전체 흐름을 기준으로 설명합니다.

---

## 1. 기능 개요

- 사용자는 특정 채팅방에 입장하여 실시간으로 메시지를 전송하고 수신함
- 메시지는 WebSocket(STOMP 프로토콜) 기반으로 주고받음
- 이전 채팅 내역은 REST API를 통해 조회

---

## 2. 프론트엔드 구성 (React)

### ✅ 주요 기능 흐름

1. **채팅방 ID 추출**

   - URL 파라미터에서 채팅방 ID를 가져와 사용

2. **기존 메시지 조회**

   - 컴포넌트 마운트 시 REST API 호출하여 과거 메시지 불러옴

3. **WebSocket 연결**

   - STOMP 클라이언트를 이용하여 서버 `/ws-stomp` 엔드포인트에 연결
   - 연결 이후 해당 채팅방에 해당하는 구독 주소(`/sub/chatrooms.{chatroomId}`)를 구독

4. **메시지 수신 처리**

   - 구독한 주소에서 메시지가 오면 기존 메시지 배열에 추가

5. **메시지 전송**
   - 사용자가 메시지를 입력 후 전송 시, 서버에 `/pub/chat.send` 주소로 메시지를 발행함

---

## 3. 백엔드 구성 (Spring Boot)

### ✅ WebSocket 설정

- `/ws-stomp` 경로로 WebSocket 연결을 수락
- STOMP 프로토콜을 사용
- 메시지 수신 경로는 `/pub/**`, 메시지 발행 경로는 `/sub/**`로 설정

---

## 4. 컨트롤러 구성

- 클라이언트로부터 STOMP 메시지를 `/pub/chat.send`로 수신
- 해당 메시지를 서비스로 전달하여 저장 및 전송 처리

---

## 5. 서비스 구성

- 메시지 수신 시:
  - 발신자와 채팅방 ID로 유효한 객체를 조회
  - 메시지를 DB에 저장
  - 저장된 메시지를 DTO로 변환
  - 해당 채팅방 구독자(`/sub/chatrooms.{chatroomId}`)에게 메시지를 브로드캐스트

---

## 6. DTO 구조

- **요청 DTO**: 클라이언트에서 보낸 채팅 메시지 정보 (채팅방 ID, 사용자 ID, 메시지 내용)
- **응답 DTO**: 저장된 메시지를 기반으로 클라이언트에 전달할 메시지 정보 (채팅방 ID, 발신자 닉네임, 내용, 생성 시간 등)

---

## 7. 보안 및 CORS

- WebSocket 경로(`/ws-stomp`, `/pub/**`, `/sub/**`)에 대해 보안 설정에서 permitAll 적용
- CORS 설정은 모든 오리진과 헤더, 메서드를 허용

---

## 8. 데이터 흐름 요약

1. 클라이언트는 `/ws-stomp`로 연결을 시도
2. 연결되면 `/sub/chatrooms.{id}` 주소를 구독
3. 메시지를 입력해 `/pub/chat.send`로 발행
4. 서버는 메시지를 저장하고, 구독자에게 `/sub/chatrooms.{id}`로 브로드캐스트
5. 구독 중인 클라이언트가 해당 메시지를 수신

---

## 9. 현재까지 완료된 기능

- 채팅방 내 이전 메시지 조회 기능
- WebSocket 연결 및 STOMP 기반 구독/발행
- 실시간 채팅 송수신
- 메시지 저장 후 자동 브로드캐스트
- 메시지에 발신자 닉네임 포함

---

## 10. 추후 고려사항 (옵션)

- 메시지 읽음 여부 처리
- 파일 전송 지원
- 서버 장애 대비 SockJS 백업 전략 필요 여부 판단
- WebSocket 연결 오류 시 UI 에러 처리

### 유저 닉네임 띄우기
# JPA에서 Lazy 로딩과 연관 객체 (User) 처리 요약

## 📌 전제: Message → User 연관관계

```java
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "USER_ID")
private User sender;
```

- `Message.sender`는 `User` 엔티티를 참조
- `fetch = FetchType.LAZY`이므로 실제 DB 조회는 **나중에(get 호출 시점)** 일어남

---

## ✅ 동작 흐름

### 1. `message.getSender()`

- Hibernate 프록시 객체만 반환됨
- 아직 DB에서 User 정보를 조회하진 않음

### 2. `message.getSender().getId()`

- `user_id`는 이미 FK로 알고 있기 때문에 **즉시 반환 가능**

### 3. `message.getSender().getNickname()`

- 이 시점에 **DB 조회 발생**
- 조건: 트랜잭션이 열려 있어야 한다 (`@Transactional` 필요)

---

## ⚠️ 주의 사항

- `@Transactional(readOnly = true)`가 없으면 Lazy 로딩 시 `LazyInitializationException` 발생
- 이 메서드 안에서는 Hibernate가 세션을 유지해야 프록시 초기화가 가능함

---

## ✅ 요약 정리

| 접근 방식 | 동작 | 트랜잭션 필요 여부 |
|-----------|------|--------------------|
| `getSender().getId()` | OK (프록시) | ❌ |
| `getSender().getNickname()` | Lazy 로딩 → DB 조회 | ✅ |

---

## 💡 정리 한 줄

> JPA는 외래키(user_id)로 프록시를 들고 있다가,  
> `getNickname()` 같은 실 데이터 접근 시 DB에서 실제 User를 조회한다.  
> 이때 트랜잭션이 없으면 실패하므로 꼭 `@Transactional`을 붙여야 한다.

# ✅ 프론트엔드 구조 리팩토링 요약 (워크샵 메신저)

## 🎯 목표
- 기존에는 라우팅(`/chatrooms/:id`) 방식으로 채팅방 진입
- 변경된 구조는 하나의 화면에서 좌우 분할(Split View) 방식으로 동작

---

## ✅ 변경 전 구조 (라우팅 기반)

1. 채팅방 목록 페이지: `/chatrooms`
2. 채팅방 상세 페이지: `/chatrooms/:id`
3. React Router의 `useParams()`를 통해 URL에서 id 추출

### ❌ 단점
- 페이지 전체가 리로드되어 UX가 끊김
- 좌/우 동시 표시가 불가능

---

## ✅ 변경 후 구조 (Split View + props 기반)

1. 하나의 컴포넌트(`ChatroomSplitView`)에서 좌측 목록 + 우측 상세를 함께 렌더링
2. 클릭한 방의 ID를 상태(state)로 저장: `selectedRoomId`
3. `ChatroomDetail` 컴포넌트에 `chatroomId`를 **props로 전달**

```jsx
<ChatroomDetail chatroomId={selectedRoomId} />
```

---

## 🧠 핵심 차이점 요약

| 방식 | 설명 | 특징 |
|------|------|------|
| 라우팅 기반 | URL 변경 → 컴포넌트 전환 | 전체 페이지 전환 |
| props 기반 | 한 화면에서 props로 ID 전달 | 부드러운 전환, UX 개선 |

---

## ✅ 결과

- 사용자는 한 화면에서 워크샵을 선택하고 바로 채팅 가능
- 더 직관적인 인터페이스 제공
- 향후 검색/미리보기/알림도 손쉽게 통합 가능

