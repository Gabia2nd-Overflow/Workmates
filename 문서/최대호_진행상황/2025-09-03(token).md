JWT 기반 인증 구조 정리
1. 기존 문제

프론트엔드에서 Lounge 생성, Message 수정/삭제, File 업로드 등의 요청을 보낼 때 토큰 없이 호출 → 백엔드(Spring Security)가 403 Forbidden 반환.

임시로 X-User-Id 헤더를 사용했지만, 이는 보안적으로 안전하지 않음.

2. 해결 방법
(1) 로그인 시 토큰 발급

AuthController → /api/auth/login 성공 시 JWT 토큰 발급.

클라이언트(LocalStorage)에 저장:

localStorage.setItem("token", response.token);

(2) 프론트 요청 시 토큰 자동 첨부

src/services/api.js 에 Axios Interceptor 적용:

api.interceptors.request.use((config) => {
  const token = localStorage.getItem("token");
  if (token) config.headers.Authorization = `Bearer ${token}`;
  return config;
});


따라서 모든 요청(workshops, lounges, messages, files)은 자동으로 Authorization: Bearer <token> 헤더 포함.

(3) 백엔드에서 토큰 검증

SecurityConfig 에 jwtAuthFilter 추가:

요청 도착 시 토큰 검증 → 유효하면 SecurityContextHolder 에 사용자 인증 정보 저장.

컨트롤러에서는 @AuthenticationPrincipal 혹은 SecurityContext 로 userId 추출 가능.

/api/workshops/**, /api/lounges/**, /api/messages/**, /api/files/** 모두 authenticated() 로 보호.

3. 앞으로 적용할 영역

✅ 모든 주요 기능에서 토큰 기반 사용자 인증 필요

LoungeController

생성(Create), 수정(Update), 삭제(Delete) 시 토큰에서 userId 추출.

권한 체크: 워크숍 멤버만 라운지 생성/수정 가능.

MessageController

메시지 작성(Send), 수정(Edit), 삭제(Delete) 시 토큰 기반으로 writerId 확인.

다른 사용자의 메시지는 수정/삭제 불가.

FileController

파일 업로드/삭제 시 토큰으로 유저 인증.

권한 없는 사용자가 업로드/삭제 못하도록 방지.

4. 요약

핵심 변경점: X-User-Id 제거 → JWT 토큰 인증으로 통일.

흐름:
로그인 → JWT 발급 → Axios Interceptor 로 자동 첨부 → Spring Security 필터에서 검증 → 컨트롤러 로직 실행.

앞으로 추가되는 모든 기능(메시지 수정/삭제, 파일 첨부 등)도 동일한 구조로 확장 가능.

👉 이 구조를 "JWT 기반 Stateless 인증 아키텍처" 라고 부르며, REST API + SPA(React) 조합에서 가장 일반적인 인증 패턴입니다.