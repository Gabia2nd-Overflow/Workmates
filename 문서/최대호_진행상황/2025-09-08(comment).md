Workmates — Comment CRUD 정식 구현 요약 (2025-09-08)

목적: 이 문서는 AI/개발자가 바로 이어서 작업할 수 있도록 “댓글(Comment) 기능”의 백엔드/프론트 구조, 경로 규칙, 데이터 흐름, 검증·보안, 에러·이슈까지 한 번에 이해하도록 정리한 A4 1~2장 요약본입니다.

1. 전체 구조 개요

백엔드: Spring Boot + JPA, JWT 인증

프론트: React + Axios(인터셉터로 Bearer 자동 첨부)

도메인 관계: Workshop → Thread → Post → Comment

경로 규칙 (댓글은 Post 하위로 귀속)

/api/workshops/{workshopId}/threads/{threadId}/posts/{postId}/comments


계층 검증: post는 thread_id만 보유하므로 서버에서

post(postId) ∈ thread(threadId)

thread(threadId) ∈ workshop(workshopId)
를 2단계로 검증한다.

2. 엔티티 스냅샷
2.1 Post (요지)

PK: id (BIGINT, AI)

FK: thread_id (NOT NULL) ← workshop_id는 없음

본문: content는 LONGTEXT 권장 (마이그레이션 필요, 아래 §8)

인덱스: (thread_id, created_at), (view_count)

2.2 Comment
@Entity @Table(name="COMMENT")
public class Comment {
  Long id;                 // PK
  Long rootId;             // 대댓글이면 "원댓글 id", 아니면 null
  Integer depth;           // 0 = 원댓글, 1+ = 대댓글 계층
  String content;          // 본문 (서버에서 trim)
  LocalDateTime writtenAt; // 작성 시각 (기본 now)
  String attachmentUrl;    // 단일 첨부 URL (unique=true)
  Boolean isDeleted;       // 소프트 삭제 플래그
  String writerId;         // JWT에서 추출
  String writerNickname;   // ★ 현재 unique=true → 운영 시 unique 제거 권장
  Long postId;             // 소속 Post
}


운영 권장: writerNickname의 unique=true는 다중 댓글 작성 시 제약 충돌을 초래할 수 있으므로 제거 권장.

3. API 설계 (Controller)

Base: /api/workshops/{wid}/threads/{tid}/posts/{pid}/comments

엔드포인트

GET / : 페이지네이션 댓글 목록

POST / : 댓글/대댓글 작성 (parentId로 대댓글 지정)

PATCH /{commentId} : 본문 수정 (작성자만)

DELETE /{commentId} : 소프트 삭제 (작성자만)

요청/응답 포맷

CreateRequest: { content: string, parentId?: number, attachmentUrl?: string }

UpdateRequest: { content: string, attachmentUrl?: string|null }

Response:

{
  "id": 10, "postId": 3, "rootId": 7, "depth": 1,
  "content": "대댓글 내용",
  "attachmentUrl": null,
  "isDeleted": false,
  "writerId": "qwe123", "writerNickname": "qwe123",
  "writtenAt": "2025-09-08T11:12:13"
}


목록은 Spring Page<Response> 형태(content, number, last 등 포함)

4. Repository & 정렬 규칙

CommentRepository

기본 조회: postId 기준 + 소프트삭제 제외

트리 정렬 권장:
ORDER BY COALESCE(root_id, id) ASC, id ASC
→ 원댓글 그룹별로 묶이고, 그룹 내에서 생성순 정렬됨.

PostRepository

existsByIdAndThreadId(postId, threadId)

ThreadRepository

existsByIdAndWorkshopId(threadId, workshopId)

5. Service 핵심 로직

목록 조회

ensurePathOrThrow(wid, tid, pid)  // 2단계 계층 검증
→ commentRepository.pageByPostIdOrderByThreaded(pid, pageable)


작성 (Create)

parentId가 있으면:
parent.postId == pid 확인 → rootId = parent.rootId ?? parent.id, depth = parent.depth + 1

writerId/nickname은 JWT에서만 (클라이언트 제공값 무시)

저장 후 DTO 변환 반환

수정 (Update)

소유자(writerId == me)만 허용

삭제된 댓글이면 400

content.trim() 저장

삭제 (Delete)

소프트 삭제 정책: isDeleted = true, content = "", attachmentUrl = null

멱등 처리(이미 삭제면 그대로 통과)

6. 보안 & 검증 정책

인증 필수: JWT → Authorization: Bearer <token> (프론트 인터셉터에서 자동 첨부)

소유자 검증: 수정/삭제는 작성자만

입력 검증: @NotBlank, @Size(max = COMMENT_MAX_LEN)

계층 검증: parentId는 같은 postId 내에서만 허용

소프트 삭제 기본, 하드 삭제는 관리자 전용 고려

7. 프론트 (React) 연동
7.1 Axios 공통 (src/services/api.js)

Base URL: /api

요청 인터셉터에서 토큰 자동 첨부

응답 인터셉터: 401 시 토큰 제거 후 /login 리다이렉트

7.2 commentAPI (named export)
export const commentAPI = {
  list: (wid, tid, pid, page=0, size=50) =>
    api.get(`/workshops/${wid}/threads/${tid}/posts/${pid}/comments`, { params: { page, size } }),
  create: (wid, tid, pid, content, parentId=null) =>
    api.post(`/workshops/${wid}/threads/${tid}/posts/${pid}/comments`, { content, parentId }),
  update: (wid, tid, pid, cid, content) =>
    api.patch(`/workshops/${wid}/threads/${tid}/posts/${pid}/comments/${cid}`, { content }),
  remove: (wid, tid, pid, cid) =>
    api.delete(`/workshops/${wid}/threads/${tid}/posts/${pid}/comments/${cid}`),
};

7.3 UI 구성 — PostComments 패턴

원댓글 입력창 1개 + 댓글별 인라인 ‘답글’ 입력창 토글

상태:
items, newContent, replyParentId, replyContent

동작:

onCreateRoot() → 원댓글 생성 → load() 재조회

toggleReply(id) → 해당 댓글 아래 입력창 오픈

submitReply() → parentId로 대댓글 생성 → load() 재조회

onUpdate() → 성공 시 해당 항목만 교체

onDelete() → 소프트삭제 반영(isDeleted=true, content="")

정렬/계층: 서버가 rootId 기준으로 내려주므로 프론트는 depth로 들여쓰기 + “ㄴ” 접두부만 표시하면 됨.

참고: 낙관적 갱신(응답 data로 즉시 삽입)도 가능하지만, 페이지네이션/정렬 일관성 확보를 위해 초기에는 저장 후 재조회 패턴을 사용.

8. 최근 이슈 & 해결
8.1 Post.content “Data too long”

원인: DB의 post.content가 작은 타입(VARCHAR/TEXT)

해결: 컬럼 타입을 LONGTEXT로 확장

ALTER TABLE post MODIFY COLUMN content LONGTEXT NOT NULL;


엔티티에 의도 명시(선택):

@Lob
@Column(nullable=false, columnDefinition="LONGTEXT")
private String content;

8.2 ESLint “never read” 경고

원인: const { data } = await ... 후 data 미사용

해결: 구조분해 제거 또는 data 즉시 사용(낙관적 갱신)

8.3 “답글” 버튼 눌러도 입력창 미출력

원인: 답글 입력창 토글 상태/뷰가 없음

해결: replyParentId/replyContent 상태 추가 + 해당 댓글 아래 인라인 입력창 렌더

8.4 경로/모듈 import 오류

import { commentAPI } from "../services/api"; (named export)

경로 대소문자/디렉터리명(services) 정확히 사용

8.5 닉네임 unique 제약

writer_nickname이 unique=true면 동일 닉네임 다중 댓글 시 제약 충돌(500) 가능

운영 권장: unique 제거

9. 테스트 체크리스트

단위/리포지토리

pageByPostIdOrderByThreaded 정렬: 원댓글→대댓글 순서 보장

existsByIdAndThreadId, existsByIdAndWorkshopId 정상 여부

서비스

다른 post의 parentId로 작성 시 400

소유자 아닌 수정/삭제 시 403

삭제 후 수정 시 400

컨트롤러

인증 없이 접근 시 401

경로 파라미터 불일치 시 404/400

프론트 E2E

원댓글 작성 → 즉시 목록 반영

답글 버튼 → 인라인 입력창 표시/취소/등록

수정/삭제 버튼 동작 및 소프트삭제 UI

10. 다음 액션(권장)

DB 마이그레이션: post.content → LONGTEXT, comment.writer_nickname unique 제거 검토

전역 예외 포맷 통일: { error: { code, message } }

닉네임 클레임 사용: JWT에 nickname 있으면 서비스에서 우선 사용

페이지네이션 UX: 더보기/무한스크롤 도입 및 정렬 옵션(최신순/그룹순) 토글

파일 첨부 확장: attachmentUrl → 복수 파일 구조로 확장 시 테이블 분리 고려

결론

댓글 CRUD는 경로 계층/소유자 검증/소프트삭제/트리 정렬까지 프로덕션 품질로 정리됨.

프론트는 공통 인터셉터 + 인라인 답글 입력창 패턴으로 UX/안정성을 확보.

스키마/제약(본문 컬럼 타입, 닉네임 unique)만 조정하면 바로 실서비스 수준으로 운용 가능.